package main

import (
	"bytes"
	"fmt"
	"net"
	"sync"
	"time"
)

const TIME_OUT = 5 * time.Second

func attributeName(TargetInfoBytes []byte, length int) (string, int) {
	attNameLength := int(TargetInfoBytes[length+2]) | (int(TargetInfoBytes[length+3]) << 8)
	attName := bytes.ReplaceAll(TargetInfoBytes[length+4:length+4+attNameLength], []byte{0x00}, []byte(""))
	length += 4 + attNameLength
	return string(attName), length
}

func sendPacket(ip string) string {
	conn, err := net.DialTimeout("tcp", ip+":135", TIME_OUT)
	if err != nil {
		return "-1"
	}
	defer conn.Close()

	_, err = conn.Write([]byte{0x05, 0x00, 0x0b, 0x03, 0x10, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xb8, 0x10, 0xb8, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x83, 0xaf, 0xe1, 0x1f, 0x5d, 0xc9, 0x11, 0x91, 0xa4, 0x08, 0x00, 0x2b, 0x14, 0xa0, 0xfa, 0x03, 0x00, 0x00, 0x00, 0x33, 0x05, 0x71, 0x71, 0xba, 0xbe, 0x37, 0x49, 0x83, 0x19, 0xb5, 0xdb, 0xef, 0x9c, 0xcc, 0x36, 0x01, 0x00, 0x00, 0x00})
	if err != nil {
		return "-1"
	}

	buffer1 := make([]byte, 1024)
	_, err = conn.Read(buffer1)
	if err != nil {
		return "-1"
	}

	digit := "x86"
	if bytes.Contains(buffer1, []byte{0x33, 0x05, 0x71, 0x71, 0xBA, 0xBE, 0x37, 0x49, 0x83, 0x19, 0xB5, 0xDB, 0xEF, 0x9C, 0xCC, 0x36}) {
		digit = "x64"
	}

	return digit
}

func getOSInfo(ip string) map[string]interface{} {
	osInfo := map[string]interface{}{
		"NetBIOS_domain_name": "",
		"DNS_domain_name":     "",
		"DNS_computer_name":   "",
		"DNS_tree_name":       "",
	}

	conn, err := net.DialTimeout("tcp", ip+":135", TIME_OUT)
	if err != nil {
		return nil
	}
	defer func(conn net.Conn) {
		err := conn.Close()
		if err != nil {
			return
		}
	}(conn)
	length := 0
	_, err = conn.Write([]byte{0x05, 0x00, 0x0b, 0x03, 0x10, 0x00, 0x00, 0x00, 0x78, 0x00, 0x28, 0x00, 0x03, 0x00, 0x00, 0x00, 0xb8, 0x10, 0xb8, 0x10, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0xa0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x00, 0x04, 0x5d, 0x88, 0x8a, 0xeb, 0x1c, 0xc9, 0x11, 0x9f, 0xe8, 0x08, 0x00, 0x2b, 0x10, 0x48, 0x60, 0x02, 0x00, 0x00, 0x00, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e, 0x54, 0x4c, 0x4d, 0x53, 0x53, 0x50, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x82, 0x08, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0xb1, 0x1d, 0x00, 0x00, 0x00, 0x0f})
	if err != nil {
		return nil
	}

	buffer2 := make([]byte, 4096)
	_, err = conn.Read(buffer2)
	if err != nil {
		return nil
	}
	digit := sendPacket(ip)

	OSVersionBytes := buffer2[0xa0-54+10 : 0xa0-54+18]
	majorVersion := int(OSVersionBytes[0])
	minorVersion := int(OSVersionBytes[1])
	buildNumber := int(OSVersionBytes[2]) | (int(OSVersionBytes[3]) << 8)
	OSVersion := fmt.Sprintf("Windows Version %d.%d Build %d %s", majorVersion, minorVersion, buildNumber, digit)

	TargetInfoLengthBytes := buffer2[int(0xa0)-54+2 : int(0xa0)-54+4]
	TargetInfoLength := int(TargetInfoLengthBytes[0]) | (int(TargetInfoLengthBytes[1]) << 8)
	trimmedBuffer2 := bytes.TrimRight(buffer2, "\x00")
	bufferLength := len(trimmedBuffer2)
	TargetInfoBytes := trimmedBuffer2[bufferLength-TargetInfoLength+4 : bufferLength]
	fmt.Println("[*] " + ip)
	fmt.Println("\t[->] OS_Version :", OSVersion)
	for k := range osInfo {
		osInfo[k], _ = attributeName(TargetInfoBytes, length)
		fmt.Println("\t[->]", k, ":", osInfo[k])
	}

	osInfo["OS_Version"] = OSVersion
	result := map[string]interface{}{ip: osInfo}
	return result
}

//func main() {
//	ip := "192.168.198.142"
//	getOSInfo(ip)
//}

func main() {
	ipPrefix := "192.168.198."
	threadCount := 20

	var wg sync.WaitGroup
	wg.Add(threadCount)

	for i := 0; i < threadCount; i++ {
		go func(start int) {
			defer wg.Done()
			for j := start; j < start+256/threadCount; j++ {
				ip := fmt.Sprintf("%s%d", ipPrefix, j)
				getOSInfo(ip)
			}
		}(i * 256 / threadCount)
	}

	wg.Wait()
}
